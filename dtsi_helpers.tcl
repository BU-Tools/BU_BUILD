set dtsi_output_path "${apollo_root_path}/kernel/hw"

#This function writes a dtsi_post_chunk file to append a XILINX axi slave so it
#  can be used as a UIO device.
#This takes the name of the device (as it appears in the DTSI file generated by xilinx)
proc AXI_DEV_UIO_DTSI_POST_CHUNK {device_name} {
    global dtsi_output_path
    assign_bd_address [get_bd_addr_segs {${device_name}/S_AXI/Reg }]
    #make sure the output folder exists
    file mkdir ${dtsi_output_path}
    set dtsi_file [open "${dtsi_output_path}/${device_name}.dtsi_post_chunk" w+]
    puts $dtsi_file "  &${device_name}{"
    puts $dtsi_file "    compatible = \"generic-uio\";"
    puts $dtsi_file "      label = \"$device_name\";"
    puts $dtsi_file "  };"
    close $dtsi_file
}

#function to create a DTSI chunk file for a full PL AXI slave.
proc AXI_DEV_UIO_DTSI_CHUNK {axi_interconnect_name axi_master_name device_name} {
    global dtsi_output_path
    puts ${axi_master_name}

    set addr [format %X [lindex [get_property OFFSET [get_bd_addr_segs *SEG*${device_name}_*]] 0] ]
    set addr_range [format %X [lindex [get_property RANGE [get_bd_addr_segs *SEG*${device_name}_*]] 0] ]

    #make sure the output folder exists
    file mkdir ${dtsi_output_path}
    
    if { [expr [string first xc7z [get_parts -of_objects [get_projects] ] ] >= 0 ] || [info exists REMOTE_C2C] } {    
	#build dtsi file for this for later    
	set dtsi_file [open "${dtsi_output_path}/$device_name.dtsi_chunk" w+]
	puts $dtsi_file "  amba_pl {"
	puts $dtsi_file "    axiSlave$device_name: $device_name@${addr} {"
	puts $dtsi_file "      compatible = \"generic-uio\";"
	puts $dtsi_file "      reg = <0x${addr} 0x${addr_range}>;"
	puts $dtsi_file "      label = \"$device_name\";"
	puts $dtsi_file "    };"
	puts $dtsi_file "  };"
	close $dtsi_file
    } else { 
	#build a dtsi_post_chunk file
	AXI_DEV_UIO_DTSI_POST_CHUNK ${device_name}
    }
}
